package net.forthecrown.commands.docs;

import com.google.common.base.Strings;
import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;
import lombok.RequiredArgsConstructor;
import net.forthecrown.commands.help.FtcHelpMap;
import net.forthecrown.commands.manager.FtcCommand;
import net.forthecrown.commands.manager.FtcCommand.Usage;
import net.forthecrown.core.FTC;
import net.forthecrown.utils.ArrayIterator;
import net.forthecrown.utils.io.PathUtil;
import net.forthecrown.utils.text.Text;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.commons.text.WordUtils;

@RequiredArgsConstructor
public class CommandDocs {
  private final boolean addDocumentStubs;

  private final Map<Package, List<CommandDocument>> documents
      = new Object2ObjectOpenHashMap<>();

  public void write(Path output) throws IOException {
    try (var writer = Files.newBufferedWriter(output)) {
      writer.write("# Table of contents");
      writer.newLine();

      int index = 1;

      // Table of contents
      for (var e: documents.entrySet()) {
        var name = packageName(e.getKey());

        writer.write(index++ + ". ");
        writer.write("[");
        writer.write(name);
        writer.write("](#");
        writer.write(packageId(e.getKey()));
        writer.write(")");
        writer.newLine();

        //int subIndex = 1;

        // Write sub paragraphs
        for (var v: e.getValue()) {
          writer.write("    ");
          // writer.write(subIndex++ + ". ");
          writer.write("- ");

          // Sub-paragraphs don't work, the hyperlinks in the titles don't
          // do anything
          // writer.write("[");

          writer.write("/");
          writer.write(v.name);

          // writer.write("]");
          // writer.write("(#");
          // writer.write(v.clickId);
          // writer.write(")");
          writer.newLine();
        }
      }

      int totalCommands = 0;

      // Write contents
      for (var e: documents.entrySet()) {
        var name = packageName(e.getKey());
        var id = packageId(e.getKey());

        writer.write("# ");
        writer.write(name);
        writer.write(" <a name=\"");
        writer.write(id);
        writer.write("\"></a>");

        for (var d: e.getValue()) {
          d.write(writer);
          ++totalCommands;
        }
      }

      // Write footer
      writeMetadata(writer, totalCommands);
    }
  }

  public void writeSeparated(Path outputDirectory) throws IOException {
    var res = PathUtil.ensureDirectoryExists(outputDirectory);

    if (res.right().isPresent()) {
      throw res.right().get();
    }

    for (var e: documents.entrySet()) {
      String pName = packageName(e.getKey());
      Path path = outputDirectory.resolve(pName.toLowerCase() + ".md");

      BufferedWriter writer = Files.newBufferedWriter(path);
      writeCategory(e.getValue(), pName, writer);
      writer.close();
    }
  }

  private void writeCategory(List<CommandDocument> documents,
                             String packageName,
                             BufferedWriter writer
  ) throws IOException {
    writer.write("---");

    writer.newLine();
    writer.write("title: ");
    writer.write('"');
    writer.write(packageName);
    writer.write('"');

    writer.newLine();
    writer.write("linkTitle: ");
    writer.write('"');
    writer.write(packageName);
    writer.write('"');

    writer.newLine();
    writer.write("type: docs");

    writer.newLine();
    writer.write("weight: 1");

    writer.newLine();
    writer.write("description: >");

    writer.newLine();
    writer.write("  ");
    writer.write(packageName);
    writer.write(" Commands");

    writer.newLine();
    writer.write("---");
    writer.newLine();
    writer.newLine();

    writer.write("# Table of Contents");
    writer.newLine();

    for (var d: documents) {
      writer.write("- [/");
      writer.write(d.name);
      writer.write("](#");
      writer.write(d.clickId);
      writer.write(")");
      writer.newLine();
    }

    writer.newLine();
    writer.write("# Commands");

    for (var d: documents) {
      d.write(writer);
    }

    writeMetadata(writer, documents.size());
  }

  private void writeMetadata(BufferedWriter writer, int written)
      throws IOException
  {
    writer.newLine();
    writer.write("# Metadata");
    writer.newLine();
    writer.write("This is an auto-generated command documentation file");
    writer.write(" generated by the FTC plugin.");

    writer.write("  ");
    writer.newLine();

    writer.write("Date: `");
    writer.write(new Date().toString());
    writer.write("`");

    writer.write("  ");
    writer.newLine();

    writer.write("Plugin version: `");
    writer.write(FTC.getPlugin().getPluginMeta().getVersion());
    writer.write("`");

    writer.write("  ");
    writer.newLine();

    writer.write("Total commands: ");
    writer.write(Text.NUMBER_FORMAT.format(written));
  }


  private String packageId(Package p) {
    return p.getName().replaceAll("\\.", "_");
  }

  private String packageName(Package p) {
    var name = p.getName();

    if (name.equalsIgnoreCase("net.forthecrown.commands")) {
      return "Uncategorized";
    }

    return WordUtils.capitalize(
        name.replaceAll("net.forthecrown.commands.", "")
            .replaceAll("\\.", " ")
    );
  }

  public void fill() {
    FtcHelpMap.getInstance()
        .getExistingCommands()
        .forEach(this::createDocumentation);

    documents.forEach((key, value) -> {
      value.sort(Comparator.comparing(document -> document.name));
    });
  }

  public void createDocumentation(FtcCommand command) {
    var pName = command.getClass().getPackageName();

    if (pName.contains("test")
        || pName.contains("click")
        || pName.contains("docs")
    ) {
      return;
    }

    String name = command.getHelpListName();
    String perm = command.getPermission();
    String desc = command.getDescription();
    List<String> aliases = command.getAliases();

    CommandDocument document = new CommandDocument(name, perm, aliases, desc);
    document.usages.addAll(command.getUsages());

    document.clickId = command.getClass().getName()
        .replace("net.forthecrown.commands.", "")
        .replace('.', '-')
        .replace("-Command", "-")
        .toLowerCase();

    var list = documents.computeIfAbsent(
        command.getClass().getPackage(),
        aPackage -> new ObjectArrayList<>()
    );
    list.add(document);
  }

  @RequiredArgsConstructor
  class CommandDocument {
    private final String name;
    private final String permission;
    private final List<String> aliases;
    private final String description;
    private final List<Usage> usages = new ObjectArrayList<>();

    private String clickId;

    public void write(BufferedWriter writer) throws IOException {
      writer.newLine();
      writer.write("## /");
      writer.write(name);
      writer.write(" <a name=\"");
      writer.write(clickId);
      writer.write("\"></a>");
      writer.newLine();

      if (!Strings.isNullOrEmpty(description)) {
        writer.write(description);

        if (description.equalsIgnoreCase("An FTC command")) {
          writer.write(" (default description)");
        }

        writer.write("  ");
        writer.newLine();
        writer.write("  ");
        writer.newLine();
      }

      writer.write("**Command metadata**:  ");
      writer.newLine();

      if (!Strings.isNullOrEmpty(permission)) {
        writer.write("Permission: `" + permission + "`  ");
        writer.newLine();
      }

      if (!aliases.isEmpty()) {
        StringJoiner joiner = new StringJoiner("`, `", "`", "`");
        for (var s: aliases) {
          joiner.add(s);
        }

        writer.write("Aliases: " + joiner);
        writer.write("  ");
        writer.newLine();
      }

      if (usages.isEmpty()) {
        return;
      }

      writer.write("### Usages");
      writer.newLine();

      writeUsagesAsBlock(writer);
    }

    void writeUsages(BufferedWriter writer) throws IOException {

      writer.write("---");
      writer.newLine();

      for (Usage u : usages) {
        writer.write("```txt");
        writer.newLine();

        String argument = "/" + name + " " + u.getArguments();
        writer.write(argument);
        writer.newLine();

        writer.write("```");
        writer.newLine();

        writer.write("**Description**:  ");
        writer.newLine();

        for (var s : u.getInfo()) {
          writer.write(StringEscapeUtils.escapeHtml4(s));

          // 2 spaces forces newline in Markdown
          writer.write("  ");
          writer.newLine();
        }

        writer.newLine();
        writer.write("---");
        writer.newLine();
      }
    }

    void writeUsagesAsBlock(BufferedWriter writer)
        throws IOException
    {
      writer.write("```yaml");
      writer.newLine();

      var uIt = usages.iterator();
      while (uIt.hasNext()) {
        var s = uIt.next();

        writer.write("/" + s.argumentsWithPrefix(name) + "");
        writer.newLine();

        if (s.getInfo().length > 0) {
          var it = ArrayIterator.unmodifiable(s.getInfo());

          while (it.hasNext()) {
            writer.write("# " + it.next());

            if (it.hasNext()) {
              writer.newLine();
            }
          }
        } else if (addDocumentStubs) {
          writer.write("> No documentation given :(  ");
        }

        if (uIt.hasNext()) {
          writer.newLine();
          writer.newLine();
        }
      }

      writer.newLine();
      writer.write("```");
      writer.newLine();
    }
  }
}