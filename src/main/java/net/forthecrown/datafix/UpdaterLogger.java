package net.forthecrown.datafix;

import lombok.Getter;
import net.forthecrown.core.Crown;
import net.forthecrown.utils.io.PathUtil;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Marker;
import org.apache.logging.log4j.message.Message;
import org.apache.logging.log4j.message.MessageFactory;
import org.apache.logging.log4j.spi.ExtendedLogger;
import org.apache.logging.log4j.spi.ExtendedLoggerWrapper;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.time.LocalDate;
import java.time.LocalTime;

public class UpdaterLogger extends ExtendedLoggerWrapper {
    @Getter
    private PrintWriter output;

    public UpdaterLogger(ExtendedLogger logger, String name, MessageFactory messageFactory) {
        super(logger, name, messageFactory);
    }

    static UpdaterLogger create() {
        ExtendedLogger logger = LogManager.getContext().getLogger("DataUpdate");
        return new UpdaterLogger(logger, logger.getName(), logger.getMessageFactory());
    }

    @Override
    public void logMessage(String fqcn, Level level, Marker marker, Message message, Throwable t) {
        // Print to console if we're on debug mode
        // of if there's no file printer to print to,
        // or if an error's being printed, console
        // should know about that lmao
        if (Crown.inDebugMode()
                || output == null
                || level == Level.ERROR
        ) {
            super.logMessage(fqcn, level, marker, message, t);
        }

        if (this.output == null) {
            return;
        }

        StringBuffer buffer = new StringBuffer();

        // Start with exception time
        LocalTime localTime = LocalTime.now().withNano(0);
        buffer
                .append(localTime)
                .append(" [")
                .append(level.toString())
                .append("] ");

        buffer.append(message.getFormattedMessage());

        Object[] params = message.getParameters();
        Throwable throwable = t;

        // If last message parameter is throwable
        if (throwable == null
                && !ArrayUtils.isEmpty(params)
                && params[params.length - 1] instanceof Throwable thrown
        ) {
            throwable = thrown;
        }

        output.println(buffer);

        // If we have a throwable to print
        // throwables should always get printed
        // to console, as it means a data
        // updater failed
        if (throwable != null) {
            output.print(' ');
            throwable.printStackTrace(output);

            super.logMessage(
                    fqcn,
                    level,
                    marker,
                    getMessageFactory().newMessage("Error running data update"),
                    t
            );
        }
    }

    /** Closes the file writer this logger uses */
    public void close() {
        output.close();
        output = null;
    }

    /**
     * Initializes the file writer this logger will use.
     * <p>
     * The update log files will be placed in the 'update_logs'.
     * Log files also follow the naming format of 'YYYY_MM_DD',
     * log names are generated by {@link #logFileName()}
     */
    public void initFilePrinter() {
        Path logFile = PathUtil.pluginPath("update_logs", logFileName());

        try {
            // Ensure the logger file exists
            // No, newBufferedWriter doesn't perform this
            // operation for us, even with the CREATE
            // open option... bruh
            if (!Files.exists(logFile)) {
                if (!Files.exists(logFile.getParent())) {
                    Files.createDirectories(logFile.getParent());
                }

                Files.createFile(logFile);
            }

            BufferedWriter writer = Files.newBufferedWriter(logFile, StandardCharsets.UTF_8,
                    StandardOpenOption.WRITE,
                    StandardOpenOption.APPEND
            );

            this.output = new PrintWriter(writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static String logFileName() {
        return LocalDate.now().toString().replaceAll("-", "_") + ".txt";
    }
}