package net.forthecrown.datafix;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.time.LocalDate;
import java.time.LocalTime;
import lombok.Getter;
import net.forthecrown.core.FTC;
import net.forthecrown.utils.io.PathUtil;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Marker;
import org.apache.logging.log4j.message.Message;
import org.apache.logging.log4j.message.MessageFactory;
import org.apache.logging.log4j.spi.ExtendedLogger;
import org.apache.logging.log4j.spi.ExtendedLoggerWrapper;

public class UpdaterLogger extends ExtendedLoggerWrapper {

  @Getter
  private PrintWriter output;

  public UpdaterLogger(ExtendedLogger logger, String name, MessageFactory messageFactory) {
    super(logger, name, messageFactory);
  }

  static UpdaterLogger create() {
    ExtendedLogger logger = LogManager.getContext().getLogger("DataUpdate");
    return new UpdaterLogger(logger, logger.getName(), logger.getMessageFactory());
  }

  @Override
  public void logMessage(String fqcn, Level level, Marker marker, Message message, Throwable t) {
    // Print to console if we're on debug mode
    // of if there's no file printer to print to,
    // or if an error's being printed, console
    // should know about that lmao
    if (FTC.inDebugMode()
        || output == null
        || level == Level.ERROR
    ) {
      super.logMessage(fqcn, level, marker, message, t);
    }

    if (this.output == null) {
      return;
    }

    StringBuffer buffer = new StringBuffer();

    // Start with exception time
    LocalTime localTime = LocalTime.now().withNano(0);
    buffer
        .append(localTime)
        .append(" [")
        .append(level.toString())
        .append("] ");

    buffer.append(message.getFormattedMessage());

    Object[] params = message.getParameters();
    Throwable throwable = t;

    // If last message parameter is throwable
    if (throwable == null
        && !ArrayUtils.isEmpty(params)
        && params[params.length - 1] instanceof Throwable thrown
    ) {
      throwable = thrown;
    }

    output.println(buffer);

    // If we have a throwable to print
    // throwables should always get printed
    // to console, as it means a data
    // updater failed
    if (throwable != null) {
      output.print(' ');
      throwable.printStackTrace(output);

      super.logMessage(
          fqcn,
          level,
          marker,
          getMessageFactory().newMessage("Error running data update"),
          t
      );
    }
  }

  /**
   * Closes the file writer this logger uses
   */
  public void close() {
    output.close();
    output = null;
  }

  /**
   * Initializes the file writer this logger will use.
   * <p>
   * The update log files will be placed in the 'update_logs'. Log files also follow the naming
   * format of 'YYYY_MM_DD', log names are generated by {@link #logFileName()}
   */
  public void initFilePrinter() {
    Path logFile = PathUtil.pluginPath("update_logs", logFileName());

    try {
      // Ensure the logger file exists
      // No, newBufferedWriter doesn't perform this
      // operation for us, even with the CREATE
      // open option... bruh
      if (!Files.exists(logFile)) {
        if (!Files.exists(logFile.getParent())) {
          Files.createDirectories(logFile.getParent());
        }

        Files.createFile(logFile);
      }

      BufferedWriter writer = Files.newBufferedWriter(logFile, StandardCharsets.UTF_8,
          StandardOpenOption.WRITE,
          StandardOpenOption.APPEND
      );

      this.output = new PrintWriter(writer);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  private static String logFileName() {
    return LocalDate.now().toString().replaceAll("-", "_") + ".txt";
  }
}