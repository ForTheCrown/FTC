package net.forthecrown.gradle

import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.plugins.JavaPluginExtension
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.util.*

internal fun createPluginYml(it: Task) {
  val configYml = it.project.extensions.findByType(FtcPaperYml::class.java) ?: return
  validateConfig(configYml, it)

  val builder = StringBuilder("# Auto-Generated by FTC Gradle plugin\n")
    .append("# Basic plugin info\n")

  builder
    .append("name: '${configYml.name}'\n")
    .append("main: '${configYml.main}'\n")
    .append("version: '${getVersion(configYml, it.project)}'\n")
    .append("api-version: '$API_VERSION'\n")

  if (configYml.prefix != null) {
    builder.append("prefix: '${configYml.prefix}'\n")
  }

  if (configYml.description != null) {
    builder.append("description: '${configYml.description}'\n")
  }

  if (configYml.authors != null && configYml.authors!!.isNotEmpty()) {
    builder.append("authors:\n")

    configYml.authors!!.forEach {
      builder.append("  - '$it'\n")
    }
  }

  builder.append("\n# Class loading/bootstrap details\n")
  builder.append("has-open-classloader: ${configYml.openClassLoader}\n")

  if (configYml.bootstrapper != null) {
    builder.append("bootstrapper: '${configYml.bootstrapper}'\n")
  }

  if (configYml.loader != null) {
    builder.append("loader: '${configYml.loader}'\n")
  }

  builder.append("\n# Dependency and load order details\n")
  builder.append("load: '${configYml.load}'\n")

  printOrderList("load-after", builder, configYml.loadAfter, it.project)
  printOrderList("load-before", builder, configYml.loadBefore, it.project)

  val dependsMap = configYml.depends.map
  if (dependsMap.isNotEmpty()) {
    builder.append("dependencies:\n")

    dependsMap.forEach { (key, value) ->
      val depName = resolveDependency(key, it.project) ?: return@forEach;

      builder
        .append("  - name: '${depName}'\n")
        .append("    required: ${!value.optional}\n")
        .append("    bootstrap: ${value.bootstrap}\n")
    }
  }

  builder.append("\n# Build metadata\nbuildDate: '${Date()}'")

  val file = it.project.file(GENERATED_CONFIG_PATH)
  val path = file.toPath()

  if (Files.exists(path)) {
    Files.delete(path)
  }

  val parent = path.parent

  if (!Files.exists(parent)) {
    Files.createDirectories(parent)
  }

  Files.writeString(path, builder.toString(), StandardCharsets.UTF_8)
}

fun resolveDependency(name: String, project: Project): String? {
  if (!name.startsWith("project:")) {
    return name;
  }

  val projName = name.replaceFirst("project:", "")
  return resolveProjectDependency(projName, project);
}

fun resolveProjectDependency(name: String, importing: Project): String? {
  val project = findProject(name, importing)

  if (project == null) {
    return name
  };

  val ftcExt = project.extensions.findByType(FtcExtension::class.java) ?: return project.name

  if (ftcExt.skipDependency) {
    return null
  }

  val implProj = ftcExt.apiFor;

  if (implProj.isNullOrEmpty()) {
    println("implProject: null|empty")
    return getProjectPluginName(project)
  }

  val depProj = findProject(implProj, project)

  if (depProj == null) {
    println("Implementation project '${implProj}' for project '${project.name}' cannot be found")
    return getProjectPluginName(project);
  }

  if (depProj == importing) {
    return null
  }

  return getProjectPluginName(depProj);
}

fun findProject(name: String, parent: Project): Project? {
  val root = parent.rootProject;
  return root.findProject(name);
}

fun getProjectPluginName(project: Project): String {
  val paperYml = project.extensions.findByType(FtcPaperYml::class.java)

  if (paperYml == null) {
    return project.name;
  } else {
    return paperYml.name;
  }
}

fun printOrderList(
    name: String,
    builder: StringBuilder,
    orderList: LoadOrderList,
    project: Project
) {
  if (orderList.list.isEmpty()) {
    return
  }

  builder.append("$name:\n")

  orderList.list.forEach {
    val depName = resolveDependency(it.key, project) ?: return@forEach

    builder
      .append("  - name: '$depName'\n")
      .append("    bootstrap: ${it.value}\n")
  }
}

fun getVersion(config: FtcPaperYml, project: Project): String {
  val version = config.version

  if (version.isBlank() || version == "unspecified") {
    return project.version.toString()
  }

  return version
}

fun validateConfig(config: FtcPaperYml, it: Task) {
  if (config.main == null) {
    throw IllegalArgumentException("${it.project.name}::pluginYml: 'main' not set")
  }

  validateJavaFileExists(it.project, config.main!!, "Main")

  if (config.bootstrapper != null) {
    validateJavaFileExists(it.project, config.bootstrapper!!, "Bootstrapper")
  }

  if (config.loader != null) {
    validateJavaFileExists(it.project, config.loader!!, "Loader")
  }
}

fun validateJavaFileExists(project: Project, fqcn: String, category: String) {
  if (fqcn.isBlank()) {
    throw IllegalArgumentException(
      "${project.name}::pluginYml: $category class is blank"
    )
  }

  val filePath = fqcn.replace(".", "/")

  val jPlugin = project.extensions.findByType(JavaPluginExtension::class.java)
  val sourceSets = jPlugin!!.sourceSets

  sourceSets.forEach { it ->
    val dirs = it.allJava.srcDirs

    dirs.forEach {
      val srcFile = it.toPath().resolve("$filePath.java")

      if (Files.exists(srcFile)) {
        return
      }
    }
  }

  throw IllegalArgumentException(
    "${project.name}::pluginYml: $category class '$fqcn' doesn't exist"
  )
}